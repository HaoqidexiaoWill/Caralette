---
title: 复杂链表链表的复制
date: 2020-10-19 22:08:46
tags: 
- Python刷题
- ListNode
- Easy

---

链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/submissions/

思路：

- 两次遍历，一次记录节点顺序
- 一次记录指针关系

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:return None
        cur = head
        # 这样初始化是保证哈希表的 key 为 None （空节点）时也有效。
        # 举个例子：若 p.random = None，则 Hash[p.random] 为 Hash[None]，
        # 又 Hash[p].random 应为 None，故应有 Hash[None] == None，
        # 即哈希表中应有 {None: None}。
        hash_map = {None:None}
        while(cur):
            hash_map[cur] = Node(cur.val)
            cur = cur.next
        cur = head
        while(cur):
            # Hash 表中的 key 为原链表的节点，value 为复制后链表的节点。
            # 因此，为 Hash[p].next 赋值实际上就是为 p 复制后的链表节点 p' 添加 next 指针，
            # 又 p.next 复制后的节点 (p.next)' 在 Hash 表中为 Hash[p.next]，
            # 故 Hash[p].next = Hash[p.next] 的含义即为，
            # 将 p 复制后的节点 p' 指向 p.next 复制后的节点 (p.next)'
            hash_map[cur].next = hash_map[cur.next]
            hash_map[cur].random = hash_map[cur.random]
            cur = cur.next
        return hash_map[head]
```